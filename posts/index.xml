<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Posts on Interpreting compilers</title><link>https://singh-yashwant.github.io/posts/</link><description>Recent content in Posts on Interpreting compilers</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sun, 30 Jul 2023 23:35:06 +0530</lastBuildDate><atom:link href="https://singh-yashwant.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Graph based data structures in LLVM</title><link>https://singh-yashwant.github.io/posts/llvm-visualization-passes/</link><pubDate>Sun, 30 Jul 2023 23:35:06 +0530</pubDate><guid>https://singh-yashwant.github.io/posts/llvm-visualization-passes/</guid><description>Compilers make heavy use of graph data structures as all the code being compiled is essentially stored as a graph. Most compilers also provide ways for visualizing these complex data structures which might come in handy while debugging, and help understanding certain optimizations. Let&amp;rsquo;s have a look at some of these data structures and how to visualize them using graphviz and LLVM passes.
Note: All the graphs we&amp;rsquo;ll produce are generated in .</description></item><item><title>Deep diving into LLVM loop unroll</title><link>https://singh-yashwant.github.io/posts/loop-unroll/</link><pubDate>Sat, 13 May 2023 00:58:19 +0530</pubDate><guid>https://singh-yashwant.github.io/posts/loop-unroll/</guid><description>Continuing on the loop optimizations covered in my last post here. Letâ€™s look at one of the key loop optimization in detail today. Loop unroll as the name suggests tries to take the key aspect of a loop out of the loop i.e. looping xD. It achieves so by copying the instructions inside the loop and reducing the number of loop iterations or completely getting rid of them as we will see now.</description></item><item><title>Loop Optimizations in compilers[Part 1]</title><link>https://singh-yashwant.github.io/posts/loop-optimizations/</link><pubDate>Sun, 02 Apr 2023 01:20:52 +0530</pubDate><guid>https://singh-yashwant.github.io/posts/loop-optimizations/</guid><description>Introduction Loops are &amp;ldquo;the&amp;rdquo; most compute intensive part of any software program making loop optimizations some of the most rewarding optimizations for a compiler. In this post, I&amp;rsquo;ll try to go over some of these optimizations which are covered by LLVM(I&amp;rsquo;m sure you&amp;rsquo;ll find them in other compilers too). This is not an extensive list you can always find more.
Loop Invariant Code Motion (Code hoisting) It&amp;rsquo;s a known coding practice to always keep definitions and constant code outside the loop.</description></item><item><title>Using git worktrees to manage large codebases</title><link>https://singh-yashwant.github.io/posts/git-worktrees/</link><pubDate>Wed, 01 Mar 2023 00:01:46 +0530</pubDate><guid>https://singh-yashwant.github.io/posts/git-worktrees/</guid><description>As the first blog in the series let&amp;rsquo;s keep it short and informative.
Introduction If you work on a large scale project like compilers you will always come across the need to have multiple versions as a part of your development arsenal. One might be the latest one(in sync with upstream), one might be for a brand new feature you are working on and the other might be some crash issue that you are investigating.</description></item></channel></rss>