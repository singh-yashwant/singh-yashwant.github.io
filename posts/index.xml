<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Posts on Interpreting compilers</title><link>https://singh-yashwant.github.io/posts/</link><description>Recent content in Posts on Interpreting compilers</description><generator>Hugo -- 0.152.2</generator><language>en</language><lastBuildDate>Sun, 30 Jul 2023 23:35:06 +0530</lastBuildDate><atom:link href="https://singh-yashwant.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Graph based data structures in LLVM</title><link>https://singh-yashwant.github.io/posts/llvm-visualization-passes/</link><pubDate>Sun, 30 Jul 2023 23:35:06 +0530</pubDate><guid>https://singh-yashwant.github.io/posts/llvm-visualization-passes/</guid><description>&lt;p&gt;Compilers make heavy use of graph data structures as all the code being compiled is essentially stored as a graph. Most compilers also provide ways for visualizing these complex data structures which might come in handy while debugging, and help understanding certain optimizations. Let&amp;rsquo;s have a look at some of these data structures and how to visualize them using graphviz and LLVM passes.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; All the graphs we&amp;rsquo;ll produce are generated in &lt;code&gt;.dot&lt;/code&gt; format. If you want to visualize them make sure you have support for graphviz in your IDE or use an online &lt;a href="https://dreampuf.github.io/GraphvizOnline/"&gt;tool&lt;/a&gt;.&lt;/p&gt;</description></item><item><title>Deep diving into LLVM loop unroll</title><link>https://singh-yashwant.github.io/posts/loop-unroll/</link><pubDate>Sat, 13 May 2023 00:58:19 +0530</pubDate><guid>https://singh-yashwant.github.io/posts/loop-unroll/</guid><description>&lt;p&gt;Continuing on the loop optimizations covered in my last post &lt;a href="../loop-optimizations"&gt;here&lt;/a&gt;. Let’s look at one of the key loop optimization in detail today. &lt;strong&gt;Loop unroll&lt;/strong&gt; as the name suggests tries to take the key aspect of a loop out of the loop i.e. looping xD. It achieves so by copying the instructions inside the loop and reducing the number of loop iterations or completely getting rid of them as we will see now. I’ll try to build up from basic examples to how it is implemented in the LLVM compiler.&lt;/p&gt;</description></item><item><title>Loop Optimizations in compilers[Part 1]</title><link>https://singh-yashwant.github.io/posts/loop-optimizations/</link><pubDate>Sun, 02 Apr 2023 01:20:52 +0530</pubDate><guid>https://singh-yashwant.github.io/posts/loop-optimizations/</guid><description>&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Loops are &amp;ldquo;the&amp;rdquo; most compute intensive part of any software program making loop optimizations some of the most rewarding optimizations for a compiler. In this post, I&amp;rsquo;ll try to go over some of these optimizations which are covered by LLVM(I&amp;rsquo;m sure you&amp;rsquo;ll find them in other compilers too). This is not an extensive list you can always find more.&lt;/p&gt;
&lt;h3 id="loop-invariant-code-motion-code-hoisting"&gt;Loop Invariant Code Motion (Code hoisting)&lt;/h3&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;It&amp;rsquo;s a known coding practice to always keep definitions and constant code outside the loop. What&amp;rsquo;s interesting is even if you don&amp;rsquo;t, the compiler will take care of it. The compiler determines if any instruction is &amp;ldquo;invariant&amp;rdquo; and moves it out of the loop. Either inside prehearder(every loop in LLVM has a preheader which has only 1 outgoing edge to the loop header) or loop exit (similarly every loop has an exit block with only 1 incoming edge).&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;</description></item><item><title>Using git worktrees to manage large codebases</title><link>https://singh-yashwant.github.io/posts/git-worktrees/</link><pubDate>Wed, 01 Mar 2023 00:01:46 +0530</pubDate><guid>https://singh-yashwant.github.io/posts/git-worktrees/</guid><description>&lt;p&gt;&lt;em&gt;As the first blog in the series let&amp;rsquo;s keep it short and informative.&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;p&gt;If you work on a large scale project like compilers you will always come across the need to have
multiple versions as a part of your development arsenal. One might be the latest one(in sync with upstream), one might be for a brand new feature you are working on and the other might be some crash issue that you are investigating.&lt;/p&gt;</description></item></channel></rss>